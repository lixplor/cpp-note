# 基础

## 简介

### C++的特点

* 是一种中级语言
* 静态类型
* 编译型语言
* 大小写敏感
* 支持面向过程和面向对象
* 支持泛型
* 是C的超集, C程序也可以当做C++程序运行


### 标准库

* 标准的C++由3个部分组成
    - 核心语言: 提供所有构建块, 包括变量, 数据类型, 常量等
    - C++标准库: 提供了大量函数, 用于操作文件, 字符串等
    - 标准模板库(STL): 提供大量方法, 用于操作数据结构等


### ANSI标准

* ANSI标准是为了确保C++的移植性: 即编写的代码在Mac, Linux, Windows平台上都可以编译运行


## 环境配置

* 需要安装C/C++编译器才能够编译代码
* 各平台编译器
    - Windows: MinGW
    - Linux: GCC
    - Mac OS: Xcode
* `g++`程序
    - g++是将GCC默认语言设置为C++的一个特殊版本, 使用C++标准库而不是C标准库
    - 常用选项
        - `-ansi`: 只支持ANSI标准的C语法. 会禁用GNU C的某些特性, 如asm和typeof关键字
        - `-c`: 只编译生成目标文件
        - `-DMACRO`: 以字符串`1`定义MACRO宏
        - `-DMACRO=DEFN`: 以字符串`DEFN`定义MACRO宏
        - `-E`: 只运行C预编译器
        - `-g`: 生成调试信息. GNU调试器可利用该信息
        - `-IDIRECTORY`: 指定额外的头文件搜索路径DIRECTORY
        - `-LDIRECTORY`: 指定额外的函数库搜索路径DIRECTORY
        - `-ILIBRARY`: 连接时搜索指定的函数库LIBRARY
        - `-m486`: 针对486进行代码优化
        - `-o File`: 生成指定的File可执行文件
        - `-O0`: 不进行优化处理
        - `-O`或`-O1`: 优化生成代码
        - `-O2`: 进一步优化
        - `-O3`: 更进一步优化, 包括`inline`函数
        - `-shared`: 生成共享目标文件. 通常用在建立共享库时
        - `-static`: 禁用共享连接
        - `-UMACRO`: 取消对MACRO宏的定义
        - `-w`: 不生成任何警告信息
        - `-Wall`: 生成所有警告信息
    - 编译代码, 生成可执行文件:
        - 最简化方式: `g++ helloworld.cpp`
            - 没有指定可执行文件名称, 默认使用`a.out`文件名
        - 指定可执行程序文件名: `g++ helloworld.cpp -o helloworld`
            - 这会生成一个名为`helloworld`的可执行文件
        - 编译多个代码文件, 生成一个可执行程序: `g++ a.cpp, b.cpp -o app`
    - 运行可执行文件
        - `./helloworld`


## 语法

* 每条语句用`;`分号结尾
* 代码块用`{}`花括号括起来
* 标识符: 用来标识变量, 函数, 类, 模块, 自定义项目的名称
    - 命名规则: 大小写英文字母`a-zA-Z`, 下划线`_`, 数字`0-9`
    - 不能使用标点符号, 如`@`, `$`, `%`
    - 英文字母和下划线可以开头, 数字不能开头
* 保留字: 具有特殊用途的单词, 不能作为标识符名称
* 三字符组: 也成为三字符序列, 用于表示另一个字符的三个字符
    - 格式: 以2个问号开头, `??x`
    - 三字符序列可以出现在任何地方, 包括字符串, 字符序列, 注释和预处理指令
    - 常见三字符序列:
        - `??=`:`#`
        - `??/`:`\`
        - `??'`:`^`
        - `??(`:`[`
        - `??)`:`]`
        - `??!`:`|`
        - `??<`:`{`
        - `??>`:`}`
        - `??-`:`~`
    - 如果希望使用2个连续的问号而不被当做三字符组, 可以使用以下2种方法:
        - 利用字符串拼接: `"what?""? oh..."`
        - 使用转义: `what?\? oh...`
    - VC++2010开始不再自动替换三字符组. g++默认支持三字符组
* 注释
    - 单行注释: `// 单行注释`
    - 多行注释: `/* 多行注释 */`
* 数据类型
    - 定义类型: `typedef`, 为已有类型取一个新名字
        - 格式: `typedef 原类型名 新类型名;`
        - 示例: `typedef unsigned char uchar;`
    - 基本数据类型(7种)
        - `bool`: 布尔型
        - `char`: 字符型
        - `wchar_t`: 宽字符型
        - `int`: 整型
        - `float`: 浮点型
        - `double`: 双精度浮点型
        - `void`: 无类型
    - 基本数据类型修饰符
        - `signed`: 有符号
        - `unsigned`: 无符号
        - `short`: 修饰int, 短整型
        - `long`: 修饰int, 长整型
    - 所以汇总起来, 有如下类型:

|类型                |位           |范围                                                     |
|--------------------|------------|---------------------------------------------------------|
|`char`              |1 个字节     |`-128 到 127` 或者 `0 到 255`                             |
|`unsigned char`     |1 个字节     |`0 到 255`                                               |
|`signed char`       |1 个字节     |`-128 到 127`                                            |
|`int`               |4 个字节     |`-2147483648 到 2147483647`                              |
|`unsigned int`      |4 个字节     |`0 到 4294967295`                                        |
|`signed int`        |4 个字节     |`-2147483648 到 2147483647`                              |
|`short int`         |2 个字节     |`-32768 到 32767`                                        |
|`unsigned short int`|2 个字节     |`0 到 65,535`                                            |
|`signed short int`  |2 个字节     |`-32768 到 32767`                                        |
|`long int`          |8 个字节     |`-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807`|
|`signed long int`   |8 个字节     |`-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807`|
|`unsigned long int` |8 个字节     |`0 to 18,446,744,073,709,551,615`                        |
|`float`             |4 个字节     |`+/- 3.4e +/- 38 (~7 个数字)`                             |
|`double`            |8 个字节     |`+/- 1.7e +/- 308 (~15 个数字)`                          |
|`long double`       |8 个字节     |`+/- 1.7e +/- 308 (~15 个数字)`                          |
|`wchar_t`           |2 或 4 个字节|1 个宽字符                                                |


* 枚举类型: 是若干枚举常量的集合
    - 格式: `enum 枚举类型名称 { 枚举常量1, 枚举常量2, ..., 枚举常量n } 变量名;`
    - 示例: `enum color {red, green, blue} c;`
    - 默认情况下, 第一个枚举常量的值为0, 第二个为1, 以此类推. 但也可以赋初始值:
        - `enum color {red, green = 5, blue} c;`, 此时, red依然是0, green是5, blue根据前面的值递增, 所以为6
* 变量
    - 定义变量格式: `类型 变量名;`
        - 示例: `int i = 1, j = 2, k;`
    - `extern`关键字: 允许变量被外部文件使用
    - 左值和右值: 左值出现在等号左边, 右值出现在等号右边
        - 左值: Lvalues, 指向内存位置的表达式
        - 右值: Rvalues, 存储在内存中某些地址的数值
    - 变量作用域:
        - 局部变量: 代码块内部
        - 形参变量: 函数形参列表中
        - 全局变量: 所有函数外部声明的变量
            - 全局变量的初始值
                - `int`: `0`
                - `char`: `'\0'`
                - `float`: `0`
                - `double`: `0`
                - 指针: `NULL`
* 常量
    - 也叫字面量, 常量是固定值, 程序执行期间不会改变
    - 常量可以是任何基本数据类型
        - 整数常量:
            - 普通数字: 十进制, `10`
            - `0x`开头: 十六进制, `0xfe`
            - `0`开头: 八进制, `078`
            - `U`结尾: unsigned int, `121U`
            - `L`结尾: long int, `213213L`
            - `UL`结尾: unsigned long int, `23213UL`
        - 浮点常量
            - `3.1415`
            - `314159E-5L`
        - 布尔常量
            - `true`
            - `false`
        - 字符常量: 在单引号中
            - 允许的字符
                - 普通字符: `'x'`
                - 转义字符: `'\t'`
                - 通用字符: `'\u02C0'`
            - `char`类型: `'a'`
            - `wchar_t`类型: `L'a'`
        - 字符串常量: 在双引号中
            - "Hello, there!"
    - 定义变量的2种方式
        - 方式1: 使用`#define`预处理器
            - 格式: `#define 常量名 值;`
            - 示例: `#define LENGTH 10;`
        - 方式2: 使用`const`关键字
            - 格式: `const 类型 常量名 = 值;`
            - 示例: `const int LENGTH = 10;`
        - 注意: 常量名按照惯例一般全写为大写字母
* 修饰符类型
    - 放置在`char`, `int`, `double`数据类型前, 用于改变基本类型的含义
    - 修饰符:
        - `signed`: 用于`char`, `int`, `long`, `short`, 有符号
        - `unsigned`: 用于`char`, `int`, `long`, `short`, 无符号
        - `long`: 用于`int`, `double`
        - `short`: 用于`int`
        - 注意: 可以不写`int`, 只写`signed`, `unsigned`, `short`, `long`, 如`signed x;`
* 类型限定符
    - `const`: 该类型的对象在程序执行期间不能被修改
    - `volatile`: 告诉编译器变量的值可能以程序未明确指定的方式被改变
    - `restrict`: 修饰指针, 表示该指针是唯一一种访问它所指向的对象的方式(C99)
* 存储类:
    - 存储类定义了变量或函数的可见性和生命周期
    - 存储类:
        - `auto`: C++11起已经不再是存储类说明符
            - 2个应用场景:
                - 声明变量时根据初始化表达式自动推断该变量的类型: `auto f = 3.14;`会推断为`double`
                - 声明函数时函数返回值的占位符
        - `register`: C++11起被弃用
            - 用于定义存储在寄存器中而不是RAM中的局部变量. 即变量的最大数据容量等于寄存器的大小: `register int miles;`
            - 不能对其使用`&`运算符, 因为没有内存位置
        - `static`
            - 指示编译器在程序的生命周期内保持局部变量的存在, 而不需要在每次它进入和离开作用域时进行创建和销毁: `static int count = 10;`
            - 修饰局部变量, 可在函数调用之间保持局部变量的值不会被重新初始化
            - 修饰全局变量, 该全局变量的作用域为所在文件内
            - 修饰成员变量, 该变量被类的所有对象共享, 相当于Java的静态变量
        - `extern`
            - 提供一个全局变量的引用, 全局变量对所有的程序文件都是可见的: `extern int count;`
            - 对于无法初始化的变量, 会把变量名指向一个之前定义过的存储位置
        - `mutable`
            - 仅适用于类的对象, 允许对象的成员替代常量, 即mutable成员可以通过const成员函数修改
        - `thread_local`: C++11
            - 该变量仅可在创建该变量的线程上访问: `thread_local std::string s;`
            - 可以与`static`, `extern`共同使用
* 运算符
    - 算数运算符
        - `+`: 加法
        - `-`: 减法
        - `*`: 乘法
        - `/`: 除法
        - `%`: 取模, 除法的余数
        - `++`: 自增
        - `--`: 自减
    - 关系运算符
        - `==`: 相等
        - `!=`: 不等
        - `>`: 大于
        - `<`: 小于
        - `>=`: 大于等于
        - `<=`: 小于等于
    - 逻辑运算符
        - `&&`: 逻辑与
        - `||`: 逻辑或
        - `!`: 逻辑非
    - 位运算符
        - `&`: 位与
        - `|`: 位或
        - `^`: 位异或
        - `~`: 取反
        - `<<`: 二进制左移
        - `>>`: 二进制右移
    - 赋值运算符
        - `=`: 赋值
        - `+=`: 加且赋值
        - `-=`: 减且赋值
        - `*=`: 乘且赋值
        - `/=`: 除且赋值
        - `%=`: 取模且赋值
        - `<<=`: 左移且赋值
        - `>>=`: 右移且赋值
        - `&=`: 位与且赋值
        - `|=`: 位或且赋值
        - `^=`: 位异或且赋值
    - 杂项运算符
        - `sizeof`: 返回变量的大小
        - `condition? X : Y;`: 三元运算符
        - `,`: 逗号运算符, 按顺序执行
        - `.`或`->`: 成员运算符, 用于引用类, 结构和共同体的成员
        - `Cast`: 强转运算符, 类型强制转换
        - `&`: 取址运算符, 返回变量的地址, `&a`
        - `*`: 指针运算符, 指向一个变量
* 循环
    - 循环类型
        - `while`
        - `for`
        - `do...while`
        - 嵌套循环
    - 循环控制语句
        - `break`: 结束循环或switch
        - `continue`: 结束本次循环
        - `goto`: 将控制转移到被标记的语句. 不建议使用
* 判断
    - `if`
    - `if...else`
    - `if...else if...else`
    - `switch case`
        - switch的参数可以是整型, 枚举, class类型
* 函数
    - 定义格式: `返回值类型 函数名(参数列表) {函数体}`
    - 函数声明: 函数可以单独声明, 实际主体可以单独定义
        - 声明格式: `返回值类型 函数名(参数列表);`
    - 调用函数
        - 注意: 函数必须先声明才能调用
    - 函数的参数
        - 向函数传递参数的3种方式
            - 传值调用: 把参数的实际值复制给函数的形参. 修改函数内的形参值对实际参数没有影响
            - 指针调用: 把参数的地址复制给形参. 修改函数内的形参值会影响实际参数
            - 引用调用: 把参数的引用复制给形参. 修改函数内的形参值会影响实际参数
        - 形参的默认值
            - 在定义函数时可以指定形参的默认值, 当调用函数时, 如果实际参数值不传, 则使用默认值
            - `int sum(int a, int b = 20) {}`
    - Lambda表达式
        - 即匿名函数. Lambda表达式把函数看做对象, 可以将其赋值给变量或作为参数传递
        - 格式:
            - 有参数: `[capture](参数) -> 返回值类型 {函数体}`
                - 如: `[](int x, int y) -> int { return 1; }`
            - 无参数: `[capture] { 函数体 }`
                - 如: `[] { i++; }`
            - 注意
                - 如果没有返回值, 可以忽略返回值
                - `[]`用于指定闭包的行为
                    - `[]`: 没有定义任何变量. 使用未定义变量会引发错误
                        - 若要使用`this`, 必须显示传入: `[this]() {this->func();}`
                    - `[x, &y]`: x以传值方式传入, y以引用方式传入
                    - `[&]`: 任何被使用到的外部变量都隐式的以引用方式引用
                        - 可以直接使用`this`
                    - `[=]`: 任何被使用到的外部变量都隐式的以传值方式引用
                        - 可以直接使用`this`
                    - `[&, x]`: x显示的以传值方式引用, 其余变量以引用方式引用
                    - `[=, &z]`: z显示的以引用方式引用, 其余变量以传值方式引用
* 数组
    - 存储相同类型元素的固定长度的集合
    - 数组由连续的内存组成, 最低地址对应第一个元素, 最高地址对应最后一个元素
    - 声明数组
        - 格式: `类型 数组名[数组长度];`
        - 示例: `double arr[10];`
    - 初始化数组
        - 指定初始元素以及长度: `double arr[2] = {1, 2};`
        - 指定初始元素, 长度自动设置: `double arr[] = {1, 2};`
    - 访问数组元素
        - `数组名[索引];`
        - 索引从`0`开始
    - 数组的指针: 指向数组第一个元素的地址值
* 字符串
    - 字符串实际上是使用`null`字符`'\0'`终止的一个一维字符数组, 所以数组的长度比字符串中字符数多1
    - 2种风格
        - C风格:
            - `char str[] = {'H', 'e', 'l', 'l', 'o', '\0'};`
            - `char str[] = "Hello";`
        - C++风格:
            - `string`类: `string str = "Hello";`
    - 操作字符串的函数
        - `strcpy(s1, s2)`: 赋值字符串s2到字符串s1
        - `strcat(s1, s2)`: 连接字符串s2到字符串s1的结尾
        - `strlen(s1)`: 返回字符串s1的长度
        - `strcmp(s1, s2)`: 如果s1和s2相同返回0; 如果s1<s2返回<0; 如果s1>s2返回>0
        - `strchr(s1, ch)`: 返回s1中字符ch第一次出现的位置的指针
        - `strstr(s1, s2)`: 返回s1中s2的第一次出现的位置的指针
* 指针
    - `指针`是一个变量, 所以指针也叫作指针变量. 其值为另一个变量的内存地址. 即指针是保存其他变量内存地址的一个变量
    - 指针的声明格式: `类型 *指针名;`
        - 如: `int *ip;`, `char *ch;`
        - **注意**:
            - 声明指针所用的类型, 仅用于限定该指针所指向的变量或常量的数据类型; 而指针本身都是十六进制数
            - `*`用于声明指针, 不加星号则会被认为是普通变量
    - 指针的使用
        - `p`: 指针中保存的地址值
        - `*p`: 指针中保存的地址值所对应的值
    - 每个变量都有一个内存地址, 该地址可以通过`&`访问, 如:
        - 声明一个变量, 并获取地址, `int a; &a;`, 会得到类似这种十六进制的地址: `0xbfebd5c0`
    - 指针的常用操作
        - 定义指针变量
        - 把变量地址值赋值给指针
        - 访问指针变量中可用地址的值
    - 常见用法
        - `int a = 10;`: 定义一个变量
        - `int *p;`: 声明一个指针
        - `p = &a;`: 获取变量a的地址值, 保存在指针变量p中
        - `p`: 获取指针保存的地址值, 即变量a的地址
        - `*p`: 获取指针保存的地址值对应的值, 即变量a的值
    - `NULL`指针: 空指针, 指针的值为NULL则被称为空指针
        - 如果: `int *p = NULL;`, 那么
            - `p`是该空指针中保存的地址值, 为`0`, 大多数操作系统上不允许访问地址为`0`的内存
            - `*p`是地址值对应的值, 为`NULL`
    - 指针的算术运算
        - 指针保存的是一个数值的地址, 所以可以进行数学运算, 包括以下4种:
            - `++`
            - `--`
            - `+`
            - `-`
        - 注意: 指针进行算术运算, 所增加的值要根据指针的类型确定, 如`int *p`的初始地址为`1000`, 因为int类型占用4个字节, 所以当`p++`时, 地址值要增加4个字节, 所以新地址值为`1004`
    - 指针的比较运算
        - 指针支持以下关系运算符
            - `==`
            - `<`
            - `>`
    - 指针与数组
        - 数组的值就是第一个元素的地址值, 可以通过指针获取该地址值后自增来遍历数组中的元素
            - `int arr[] = {1, 2}; int *p; p = arr;`, `p`就是数组元素的地址值, `*p`就是地址值所对应的元素值
        - 注意: 数组和指针并不能完全互换, 只有指针可以通过算数运算改变地址值, 而数组变量的值是第一个元素地址值的常量, 不能进行算数运算
    - 指针数组和数组指针
        - 指针数组是存储元素为指针的数组: `int *p[]`
            - 通常保存字符串就使用指针数组
                - `const char *names = {"hello", "world"};`
                    - 其中每个字符串都是一个字符数组, 而数组可以用指向第一个元素地址值的指针来表示, 相当于names数组是保存了字符数组的指针
        - 数组指针是一个数组的指针: `int arr[]; int *p; p = arr;`
    - 指针函数和函数指针
        - 指针函数是返回值类型为指针的函数
            - `int *sum();`, 返回值是一个int类型的指针
            - 不能返回局部变量的地址值, 除非该局部变量使用`static`修饰
            - 注意: 函数也能接收指针类型参数的函数, 但这不叫指针函数
                - `void sum(int *p);`
                - 参数为指针一般可以用于接收`数组`, `函数`
        - 函数指针是指向函数的指针
            - 声明函数指针: `int (*sum)(int a, int b);`, 这是声明一个int类型的指针, 指向函数`sum(int a, int b)`
            - 使用函数指针: `int result = (*sum)(1, 2);`
    - 二级指针
        - 二级指针是指向指针的指针
        - 多级指针会形成指针链
        - 因为指针存储的是变量的地址值, 而指针本身也是变量, 所以另一个指针也可以存储第一个指针变量的地址值
            - `int var; int *p1; int **p2; p1 = &var; p2 = &p1;`
* 引用
    - 引用变量是一个别名, 即为某一个已存在变量的另一个名字
    - 引用和指针
        - 不能存在空引用, 引用必须连接到一个合法的内存
        - 一旦医用被初始化为一个对象, 就不能指向另一个对象; 而指针可以在任何时候指向另一个对象
        - 引用必须在创建时被初始化; 指针可以在任何时候初始化
    - 创建引用
        - 格式: `数据类型& 引用名称`, `&`可以读作`引用`
        - `int i = 0; int& reference = i;`, 即reference使一个初始化为i的整型引用
    - 引用的用途
        - 将引用作为参数: `int sum(int& a, int &b);`
        - 将引用作为返回值: `int& sum(int a, int b);`
* 数据结构
    - `结构体`是一种自定义的数据类型, 其中可以存储不同类型的数据
    - 定义结构体: `struct`
        - 格式: `struct 结构体类型 { 成员类型1 成员名称1; 成员类型2 成员名称2;} 结构体变量名;`
            - 结构体变量名的数量可以是0个或多个
        - 示例: `struct Books { char title[50]; int book_id;} book;`
    - 访问结构体
        - 成员访问运算符: `.`
            - `book.title;`
    - 结构体作为函数的参数
        - `void addBook(struct Books book);`
    - 结构体的指针
        - 声明指针: `struct Books *p;`
        - 获取结构体的地址: `p = &book;`
        - 通过指针访问结构体成员: 使用`->`运算符
            - `p->title;`
    - 结构体的别名: `typedef`
        - `typedef struct {char title[50];} Books;`, `Books book;`
* IO库
    - `<iostream>`
        - `cin`: 标准输入流
        - `cout`: 标准输出流
        - `cerr`: 非缓冲标准错误流, 插入流的内容会被立刻输出
        - `clog`: 缓冲标准日志流, 插入流的内容先存储在缓冲区, 直到缓冲区填满或刷新才会输出
    - `<iomanip>`
    - `<fstream>`: 文件操作流
    - 运算符
        - `<<`: 流插入运算符
            - `cout << "hello" << "world" << endl;`
        - `>>`: 流提取运算符
            - `char input[50]; cin >> input;`, 可以将用户输入的文字保存在input数组中
        - `endl`: 换行, 需要使用命名空间`using namespace std;`
* 数学库
    - `<cmath>`: 用于数学计算
    - 生成随机数步骤
        1. 调用`srand()`设置种子
        2. 调用`rand()`获取随机数
* 日期库
    - `<ctime>`



### HelloWorld

```cpp
#include <iostream>                // 引入头文件
using namespace std;               // 命名空间

int main() {                       // 程序入口
    cout << "Hello World!";       // 输出语句
    return 0;                      // 返回0表示正常退出
}
```
